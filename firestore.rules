/**
 * @file Firestore Security Rules for Ahorro Ya
 * @description This ruleset enforces a multi-tenant security model, granting access based on user identity and tenant membership.
 *
 * Data Structure:
 * - /tenants/{tenantId}: Stores tenant information, with 'ownerUid' indicating the owner.
 * - /licenses/{licenseId}: Stores license details for tenants, linked by 'tenantId'.
 * - /memberships/{membershipId}: Tracks user memberships within tenants, including role ('owner', 'admin', 'member').
 * - /users/{userId}: Stores user profile data. 'isSuperadmin' field grants elevated privileges.
 * - /currencies/{currencyCode}: Stores currency data. Publicly readable.
 * - /fx_rates/{fxRateId}: Stores foreign exchange rates, associated with a 'tenantId'.
 * - /categories/{categoryId}: Stores expense categories, associated with a 'tenantId'.
 * - /subcategories/{subcategoryId}: Stores expense subcategories, associated with a 'tenantId'.
 * - /entities/{entityId}: Stores business/bank entities, associated with a 'tenantId'.
 * - /expenses/{expenseId}: Stores expense records, associated with a 'tenantId' and 'userId'.
 * - /budgets/{budgetId}: Stores monthly budget data, associated with a 'tenantId'.
 * - /alerts/{alertId}: Stores alert notifications, associated with a 'tenantId'.
 * - /receipts_raw/{receiptRawId}: Stores raw receipt OCR data, associated with a 'tenantId' and 'userId'.
 * - /receipts_fingerprints/{receiptFingerprintId}: Stores receipt fingerprints for deduplication.
 * - /audit_logs/{auditLogId}: Stores audit log entries, associated with a 'tenantId'.
 *
 * Key Security Decisions:
 * - Strict tenant-based data isolation: Users can only access data within tenants they are members of.
 * - Ownership enforcement: Certain collections (e.g., /tenants) are owned by specific users.
 * - Superadmin override: Users with 'isSuperadmin' set to true have unrestricted access.
 * - No user listing: Listing users is disallowed for privacy and security.
 * - Read-only currencies collection: Currencies are publicly readable.
 * - Default deny: Any access not explicitly allowed is denied.
 *
 * Denormalization for Authorization:
 * - 'tenantId' is included in almost all collections to avoid expensive 'get()' calls in security rules.
 * - 'userId' is included in the 'expenses' and 'receipts_raw' collections to quickly check ownership.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     * @principle Requires authentication for certain actions.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's UID matches the provided userId.
     * @param {string} userId - The user ID to compare against.
     * @returns {boolean} True if the UIDs match, false otherwise.
     * @principle Enforces path-based ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the user is the owner of an existing resource
     * @param {string} userId - The user ID to compare against.
     * @returns {boolean} True if the UIDs match, false otherwise.
     * @principle Enforces path-based ownership for update and delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the user is a member of the tenant associated with the resource.
     * @param {string} tenantId - The tenant ID to compare against.
     * @returns {boolean} True if the user is a member of the tenant, false otherwise.
     * @principle Enforces tenant-based access control.
     */
    function isTenantMember(tenantId) {
        return isSignedIn() && exists(/databases/$(database)/documents/memberships/$(request.auth.uid + '_' + tenantId));
    }

    /**
     * @description Checks if the user is a superadmin.
     * @returns {boolean} True if the user is a superadmin, false otherwise.
     * @principle Allows superadmins to bypass certain restrictions.
     */
    function isSuperadmin() {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isSuperadmin == true;
    }

    /**
     * @description Enforces that the incoming resource has a tenantId matching the expected tenantId.
     * @param {string} tenantId - The expected tenant ID.
     * @returns {boolean} True if the tenantId matches, false otherwise.
     * @principle Validates relational integrity.
     */
    function isTenantIdValid(tenantId) {
        return request.resource.data.tenantId == tenantId;
    }

    /**
     * @description Enforces that the incoming resource has a userId matching the request auth UID.
     * @returns {boolean} True if the userId matches, false otherwise.
     * @principle Validates relational integrity.
     */
    function isUserIdValid() {
        return request.resource.data.userId == request.auth.uid;
    }

    /**
     * @description Enforces immutability of the 'tenantId' field on updates.
     * @param {string} tenantId - The expected tenant ID.
     * @returns {boolean} True if the tenantId is unchanged, false otherwise.
     * @principle Prevents modification of critical relational fields.
     */
    function isTenantIdImmutable(tenantId) {
        return resource.data.tenantId == tenantId;
    }

    /**
     * @description Enforces immutability of the 'userId' field on updates.
     * @returns {boolean} True if the userId is unchanged, false otherwise.
     * @principle Prevents modification of critical relational fields.
     */
     function isUserIdImmutable() {
        return resource.data.userId == request.auth.uid;
    }

    /**
     * @description Rules for the /tenants collection.
     * @path /tenants/{tenantId}
     * @allow (create) - User with matching UID creates a tenant with their UID as ownerUid.
     * @allow (get, update, delete) - Tenant owner can get, update, and delete the tenant.
     * @deny (create) - User tries to create a tenant with an ownerUid that doesn't match their UID.
     * @deny (list) - Listing tenants is not allowed.
     * @principle Enforces owner-only access to tenant data.
     */
    match /tenants/{tenantId} {
      allow get: if isSignedIn() && resource.data.ownerUid == request.auth.uid;
      allow list: if false;
      allow create: if isSignedIn() && request.auth.uid == request.resource.data.ownerUid && request.resource.id == tenantId;
      allow update: if isExistingOwner(resource.data.ownerUid);
      allow delete: if isExistingOwner(resource.data.ownerUid);
    }

    /**
     * @description Rules for the /licenses collection.
     * @path /licenses/{licenseId}
     * @allow (create, get, update, delete) - Tenant member can create, get, update, and delete licenses associated with their tenant.
     * @deny (create) - User tries to create a license for a tenant they are not a member of.
     * @deny (list) - Listing licenses is not allowed.
     * @principle Enforces tenant-based access control for license data.
     */
    match /licenses/{licenseId} {
      allow get: if isSignedIn() && isTenantMember(resource.data.tenantId);
      allow list: if false;
      allow create: if isSignedIn() && isTenantMember(request.resource.data.tenantId);
      allow update: if isSignedIn() && isTenantMember(resource.data.tenantId) && isTenantIdImmutable(resource.data.tenantId);
      allow delete: if isSignedIn() && isTenantMember(resource.data.tenantId);
    }

    /**
     * @description Rules for the /memberships collection.
     * @path /memberships/{membershipId}
     * @allow (get) - User can read their own membership documents (ID format: userId_tenantId).
     * @allow (create) - User can create a membership document where the ID is a composite of their uid and the tenantId.
     * @allow (update, delete) - Tenant admin or owner can update/delete memberships.
     * @deny (list) - Listing memberships is not allowed.
     * @principle Enforces tenant-based access control and role-based modification for memberships.
     * @note Fixed circular dependency: Users can read their own memberships without needing to verify tenant membership first.
     */
    match /memberships/{membershipId} {
      allow get: if isSignedIn() && membershipId.matches(request.auth.uid + '_.*');
      allow list: if false;
      allow create: if isSignedIn() && request.resource.id == request.auth.uid + '_' + request.resource.data.tenantId;
      allow update: if isSignedIn() && isTenantMember(resource.data.tenantId) && isTenantIdImmutable(resource.data.tenantId);
      allow delete: if isSignedIn() && isTenantMember(resource.data.tenantId);
    }

    /**
     * @description Rules for the /users collection.
     * @path /users/{userId}
     * @allow (create) - User can create their own user document.
     * @allow (get, update, delete) - User can get, update, and delete their own user document. Superadmins can bypass these restrictions.
     * @deny (list) - Listing users is not allowed.
     * @principle Enforces owner-only access to user data, with superadmin override.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isSuperadmin();
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.id == userId;
      allow update: if isExistingOwner(userId) || isSuperadmin();
      allow delete: if isExistingOwner(userId) || isSuperadmin();
    }

    /**
     * @description Rules for the /currencies collection.
     * @path /currencies/{currencyCode}
     * @allow (get, list) - All users can read currency data.
     * @deny (create, update, delete) - No one can create, update, or delete currency data (read-only).
     * @principle Provides public read access to currency data.
     */
    match /currencies/{currencyCode} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Rules for the /fx_rates collection.
     * @path /fx_rates/{fxRateId}
     * @allow (create, get, update, delete) - Tenant member can create, get, update, and delete fx rates associated with their tenant.
     * @deny (create) - User tries to create an fx rate for a tenant they are not a member of.
     * @deny (list) - Listing fx rates is not allowed.
     * @principle Enforces tenant-based access control for fx rate data.
     */
    match /fx_rates/{fxRateId} {
      allow get: if isSignedIn() && isTenantMember(resource.data.tenantId);
      allow list: if false;
      allow create: if isSignedIn() && isTenantMember(request.resource.data.tenantId) && isTenantIdValid(request.resource.data.tenantId);
      allow update: if isSignedIn() && isTenantMember(resource.data.tenantId) && isTenantIdImmutable(resource.data.tenantId);
      allow delete: if isSignedIn() && isTenantMember(resource.data.tenantId);
    }

    /**
     * @description Rules for the /categories collection.
     * @path /categories/{categoryId}
     * @allow (create, get, update, delete) - Tenant member can create, get, update, and delete categories associated with their tenant.
     * @deny (create) - User tries to create a category for a tenant they are not a member of.
     * @deny (list) - Listing categories is not allowed.
     * @principle Enforces tenant-based access control for category data.
     */
    match /categories/{categoryId} {
      allow get: if isSignedIn() && isTenantMember(resource.data.tenantId);
      allow list: if isSignedIn() && isTenantMember(resource.data.tenantId);
      allow create: if isSignedIn() && isTenantMember(request.resource.data.tenantId) && isTenantIdValid(request.resource.data.tenantId);
      allow update: if isSignedIn() && isTenantMember(resource.data.tenantId) && isTenantIdImmutable(resource.data.tenantId);
      allow delete: if isSignedIn() && isTenantMember(resource.data.tenantId);
    }

    /**
     * @description Rules for the /subcategories collection.
     * @path /subcategories/{subcategoryId}
     * @allow (create, get, update, delete) - Tenant member can create, get, update, and delete subcategories associated with their tenant.
     * @deny (create) - User tries to create a subcategory for a tenant they are not a member of.
     * @deny (list) - Listing subcategories is not allowed.
     * @principle Enforces tenant-based access control for subcategory data.
     */
    match /subcategories/{subcategoryId} {
      allow get: if isSignedIn() && isTenantMember(resource.data.tenantId);
      allow list: if isSignedIn() && isTenantMember(resource.data.tenantId);
      allow create: if isSignedIn() && isTenantMember(request.resource.data.tenantId) && isTenantIdValid(request.resource.data.tenantId);
      allow update: if isSignedIn() && isTenantMember(resource.data.tenantId) && isTenantIdImmutable(resource.data.tenantId);
      allow delete: if isSignedIn() && isTenantMember(resource.data.tenantId);
    }

    /**
     * @description Rules for the /entities collection.
     * @path /entities/{entityId}
     * @allow (create, get, update, delete) - Tenant member can create, get, update, and delete entities associated with their tenant.
     * @deny (create) - User tries to create an entity for a tenant they are not a member of.
     * @deny (list) - Listing entities is not allowed.
     * @principle Enforces tenant-based access control for entity data.
     */
    match /entities/{entityId} {
      allow get: if isSignedIn() && isTenantMember(resource.data.tenantId);
      allow list: if isSignedIn() && isTenantMember(resource.data.tenantId);
      allow create: if isSignedIn() && isTenantMember(request.resource.data.tenantId) && isTenantIdValid(request.resource.data.tenantId);
      allow update: if isSignedIn() && isTenantMember(resource.data.tenantId) && isTenantIdImmutable(resource.data.tenantId);
      allow delete: if isSignedIn() && isTenantMember(resource.data.tenantId);
    }

    /**
     * @description Rules for the /expenses collection.
     * @path /expenses/{expenseId}
     * @allow (create, get, update, delete) - Tenant member can create, get, update, and delete expenses associated with their tenant and owned by the user.
     * @deny (create) - User tries to create an expense for a tenant they are not a member of.
     * @deny (list) - Listing expenses is not allowed.
     * @principle Enforces tenant-based access control and ownership for expense data.
     */
    match /expenses/{expenseId} {
      allow get: if isSignedIn() && isTenantMember(resource.data.tenantId) && resource.data.userId == request.auth.uid;
      allow list: if isSignedIn() && isTenantMember(resource.data.tenantId);
      allow create: if isSignedIn() && isTenantMember(request.resource.data.tenantId) && isTenantIdValid(request.resource.data.tenantId) && isUserIdValid();
      allow update: if isSignedIn() && isTenantMember(resource.data.tenantId) && isTenantIdImmutable(resource.data.tenantId) && isUserIdImmutable() && resource.data.userId == request.auth.uid;
      allow delete: if isSignedIn() && isTenantMember(resource.data.tenantId) && resource.data.userId == request.auth.uid;
    }

    /**
     * @description Rules for the /budgets collection.
     * @path /budgets/{budgetId}
     * @allow (create, get, update, delete) - Tenant member can create, get, update, and delete budgets associated with their tenant.
     * @deny (create) - User tries to create a budget for a tenant they are not a member of.
     * @deny (list) - Listing budgets is not allowed.
     * @principle Enforces tenant-based access control for budget data.
     */
    match /budgets/{budgetId} {
      allow get: if isSignedIn() && isTenantMember(resource.data.tenantId);
      allow list: if isSignedIn() && isTenantMember(resource.data.tenantId);
      allow create: if isSignedIn() && isTenantMember(request.resource.data.tenantId) && isTenantIdValid(request.resource.data.tenantId);
      allow update: if isSignedIn() && isTenantMember(resource.data.tenantId) && isTenantIdImmutable(resource.data.tenantId);
      allow delete: if isSignedIn() && isTenantMember(resource.data.tenantId);
    }

    /**
     * @description Rules for the /alerts collection.
     * @path /alerts/{alertId}
     * @allow (create, get, update, delete) - Tenant member can create, get, update, and delete alerts associated with their tenant.
     * @deny (create) - User tries to create an alert for a tenant they are not a member of.
     * @deny (list) - Listing alerts is not allowed.
     * @principle Enforces tenant-based access control for alert data.
     */
    match /alerts/{alertId} {
      allow get: if isSignedIn() && isTenantMember(resource.data.tenantId);
      allow list: if isSignedIn() && isTenantMember(resource.data.tenantId);
      allow create: if isSignedIn() && isTenantMember(request.resource.data.tenantId) && isTenantIdValid(request.resource.data.tenantId);
      allow update: if isSignedIn() && isTenantMember(resource.data.tenantId) && isTenantIdImmutable(resource.data.tenantId);
      allow delete: if isSignedIn() && isTenantMember(resource.data.tenantId);
    }

    /**
     * @description Rules for the /receipts_raw collection.
     * @path /receipts_raw/{receiptRawId}
     * @allow (create, get, update, delete) - Tenant member can create, get, update, and delete receipt raw data associated with their tenant and owned by the user.
     * @deny (create) - User tries to create a receipt raw data for a tenant they are not a member of.
     * @deny (list) - Listing receipt raw data is not allowed.
     * @principle Enforces tenant-based access control and ownership for receipt raw data.
     */
    match /receipts_raw/{receiptRawId} {
      allow get: if isSignedIn() && isTenantMember(resource.data.tenantId) && resource.data.userId == request.auth.uid;
      allow list: if false;
      allow create: if isSignedIn() && isTenantMember(request.resource.data.tenantId) && isTenantIdValid(request.resource.data.tenantId) && isUserIdValid();
      allow update: if isSignedIn() && isTenantMember(resource.data.tenantId) && isTenantIdImmutable(resource.data.tenantId) && isUserIdImmutable() && resource.data.userId == request.auth.uid;
      allow delete: if isSignedIn() && isTenantMember(resource.data.tenantId) && resource.data.userId == request.auth.uid;
    }

    /**
     * @description Rules for the /receipts_fingerprints collection.
     * @path /receipts_fingerprints/{receiptFingerprintId}
     * @allow (create, get, update, delete) - All users can read and write receipt fingerprint data, as this is only used for deduplication and contains no sensitive information.
     * @deny (create) - User tries to create a receipt fingerprint for a tenant they are not a member of.
     * @deny (list) - Listing receipt fingerprints is not allowed.
     */
    match /receipts_fingerprints/{receiptFingerprintId} {
      allow get: if true;
      allow list: if false;
      allow create: if true;
      allow update: if true;
      allow delete: if true;
    }

    /**
     * @description Rules for the /audit_logs collection.
     * @path /audit_logs/{auditLogId}
     * @allow (create, get, update, delete) - Tenant member can create, get, update, and delete audit logs associated with their tenant.
     * @deny (create) - User tries to create an audit log for a tenant they are not a member of.
     * @deny (list) - Listing audit logs is not allowed.
     * @principle Enforces tenant-based access control for audit log data.
     */
    match /audit_logs/{auditLogId} {
      allow get: if isSignedIn() && isTenantMember(resource.data.tenantId);
      allow list: if false;
      allow create: if isSignedIn() && isTenantMember(request.resource.data.tenantId) && isTenantIdValid(request.resource.data.tenantId);
      allow update: if isSignedIn() && isTenantMember(resource.data.tenantId) && isTenantIdImmutable(resource.data.tenantId);
      allow delete: if isSignedIn() && isTenantMember(resource.data.tenantId);
    }
  }
}